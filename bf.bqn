âŸ¨CompileâŸ©â‡

Merge â† {(â‹â‹ğ•¨)âŠâˆ¾(/â¼ğ•¨)â¥ŠÂ¨ğ•©}

Header â† {
  ğ•Šsize:
  nâ€¿s â† â€¢FmtÂ¨8â€¿1Ã—âŒˆsizeÃ·8
"
section .text
global _start
_start:
    mov rax, 12
    mov rdi, 0
    syscall
    mov rdi, rax
    mov r8, rax
    add rdi, "âˆ¾nâˆ¾"
    mov rax, 12
    syscall
    mov rsi, rax
    mov rcx, "âˆ¾sâˆ¾"
    xor rdx, rdx
bf_memset:
    sub rsi, 8
    mov qword[rsi], rdx
    dec rcx
    jnz bf_memset
"
}

footer â† "
    mov rax, 60
    mov rdi, 0
    syscall
bf_infinite_loop:
    jmp bf_infinite_loop
"

FwdJmp â† {
  f â† â€¢FmtÂ¨ğ•©
"b"âŠ¸âˆ¾Â¨fâˆ¾Â¨":
    mov al, BYTE [rsi]
    test al, al
    jz f"âŠ¸âˆ¾Â¨fâˆ¾Â¨(@+10)
}

BckJmp â† {
  fâ†â€¢FmtÂ¨ğ•©
"    jmp b"âŠ¸âˆ¾Â¨fâˆ¾Â¨"
f"âŠ¸âˆ¾Â¨fâˆ¾Â¨<":
"
}

Plus â† {
"    mov al, "âŠ¸âˆ¾Â¨(â€¢FmtÂ¨ 256|ğ•©)âˆ¾Â¨<"
    add al, BYTE [rsi]
    mov BYTE[rsi], al
"
}

Left â†  ("    sub rsi, "âˆ¾â€¢Fmtâˆ¾(@+10)Ë™)Â¨

Right â† ("    add rsi, "âˆ¾â€¢Fmtâˆ¾(@+10)Ë™)Â¨

read â† "    mov BYTE [rsi], dl
    mov rax, 0
    mov rdi, 0
    mov rdx, 1
    syscall
"

write â† "    mov rax, 1
    mov rdi, 1
    mov rdx, 1
    syscall
"

# we interpret the loop to find the increments and decrements on variables,
# then we find the modular pseudo-inverse of the loop counter's increment.
Unroll â† {tâ€¿câ€¿i:

  off â† +`cÃ—-Ë"><"=âŒœt
  sum â† 256|cÃ—-Ë"+-"=âŒœt

  # normalize increments. 0 will come first.
  uoffâ†â·0âˆ¾(sumâ‰ 0)/off
  usumâ†(uoff=âŒœoff) +Â´âˆ˜/â‰1 sum

  decrement â† -âŠusum
  uoff 1âŠ¸â†“â†©
  usum 1âŠ¸â†“â†©

  # the largest power of two dividing the increment.
  # we introduce an assertion that the initial value of the cell is
  # divisible by this value, otherwise we can just halt the program.

  pow2    â† âŠ‘(âŒ½2â‹†â†•9)(âŠ£/Ëœ0=|)decrement
  # TODO: test that this is correct!
  # pow2 â† 2Ã·Ëœ1+ âŠ‘decrement 8â€¿8â€¢bit._xorâ—‹(â¥Š256âŠ¸|) Â¯1+decrement

  modulus â† 256Ã·pow2
  # TODO: make this more efficient
  inverse â† âŠ‘/pow2=â—‹(256âŠ¸|)decrementÃ—â†•modulus

  result â† (1=pow2)âŠ‘âŸ¨
"    mov cl, BYTE[rsi]
    test cl, cl
    jz u"âˆ¾(â€¢Fmt i)âˆ¾"
    mov al, cl
    and al, "âˆ¾(â€¢Fmt pow2-1)âˆ¾"
    jnz bf_infinite_loop
    shr cl, "âˆ¾(â€¢Fmt 2â‹†â¼pow2)âˆ¾"
    mov BYTE[rsi], 0
"
    (0=â‰ off)âŠ‘âŸ¨
"    mov cl, BYTE[rsi]
    test cl, cl
    jz u"âˆ¾(â€¢Fmt i)âˆ¾"
    mov BYTE[rsi], 0
",
"    mov BYTE[rsi], 0
"
    âŸ©
  âŸ©

  result âˆ¾â†© âˆ¾{
    mem â† "BYTE[rsi"âˆ¾("-+"âŠËœğ•¨â‰¥0)âˆ¾(â€¢Fmt|ğ•¨)âˆ¾']'
    (1=256|inverseÃ—ğ•©)âŠ‘âŸ¨
"    mov al, cl
    mov dl, "âˆ¾(â€¢Fmt 256|ğ•©Ã—inverse)âˆ¾"
    mul dl
    add al, "âˆ¾memâˆ¾"
    mov "âˆ¾memâˆ¾", al
",
"    mov al, cl
    add al, "âˆ¾memâˆ¾"
    mov "âˆ¾memâˆ¾", al
"
    âŸ©
  }Â¨Â´ uoffâ€¿usum

  result âˆ¾â†© "u"âˆ¾(â€¢Fmt i)âˆ¾":
"
  result
}

Compile â‡ {
  ###### Parsing
  # Run-length encoding of the instructions: "+-<>" are joined.
  input â† âˆŠâŸœ"+-<>,.[]"âŠ¸/ğ•©
  split â† (â‰ âŸœÂ» âˆ¨ Â¬âˆ˜âˆŠâŸœ"+-<>")input
  type  â† split/input
  count â† 1â†“/â¼+`split

  # To generate matching IDs for the forward and backward jumps, we first compute
  # a depth vector. For any given depth, the closing brace of a pair always
  # occurs before any other closing brace at the same depth. This means that the
  # 'âŠ’' primitive gives the index in 'ends' of the brace that closes the scope which
  # each element in 'begin' opens.
  beginsâ€¿ends â† /Â¨begin_maskâ€¿end_mask â† "[]"=Â¨<type
  depth â† +`begin_maskÂ»âŠ¸-end_mask
  "Unmatched braces in source file"! (begins =â—‹â‰  ends) âˆ§ 0=âŒŠÂ´depth
  matching â† begins â‹âŠ¸âŠâ—‹(â‹âŠâŸœdepth) ends

  ###### Loop unrolling
  # Find the deepest nested braces for loop unrolling. These are the ones where
  # the closest closing brace on the right is the same as the matching brace.
  leaf_indices â† /matching=endsâ‹begins
  leaf_bodies â† begins {(1+ğ•¨)â†“Â¨ğ•©â†‘Â¨typeâ€¿count}Â¨â—‹(leaf_indicesâŠ¸âŠ) matchingâŠends

  unrollable â† {tâ€¿c: (Â¬âˆ¨Â´â¥Š",."=âŒœt) âˆ§ 0=+Â´cÃ—-Ë"><"=âŒœt }Â¨leaf_bodies
  unroll_beginsâ€¿unroll_ends â† (unrollable/leaf_indices)âŠ¸âŠÂ¨beginsâ€¿(matchingâŠends)
  unroll_mask â† Â¬(â‰ type)â†‘/â¼âˆ¾1+unroll_begins+â†•Â¨unroll_ends-unroll_begins

  leftover_loop_starts â† Â¬âˆ˜unrollableâŒ¾(leaf_indicesâŠ¸âŠ)(â‰ begins)â¥Š1
  leftover_loop_ends   â† (â‹matching)âŠleftover_loop_starts

  type â†© 'u'Â¨âŒ¾(unroll_beginsâŠ¸âŠ) type
  countâ€¿type â†© countâ€¿type/ËœÂ¨< unroll_mask

  ###### Code generation
  instructions â† âŸ¨
    Plus  ('+'=type)/count
    Plusâˆ˜-('-'=type)/count
    Left  ('<'=type)/count
    Right ('>'=type)/count
    <read
    <write
    FwdJmp leftover_loop_starts/matching
    BckJmp leftover_loop_ends/â†•â‰ begins
    UnrollÂ¨ unrollable/leaf_bodiesâˆ¾Â¨leaf_indices
  âŸ©

  output â† âˆ¾("+-<>,.[]u"âŠtype) Merge instructions
  (Header ğ•¨)âˆ¾outputâˆ¾footer
}

â€¢Out 30000 Compile â€¢file.Bytes âŠ‘ â€¢args
