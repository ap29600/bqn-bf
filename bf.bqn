Unlines â† âˆ¾âŸœ(@+10)âŠ¸âˆ¾Â´

# allocate 32KiB with the 'brk' syscall.
# TODO: make the amount of memory configurable.
# TODO: write a more efficient version of memset
#       to zero the initial memory.
header â† UnlinesâŸ¨
  "section .text"
  "global _start"
  "_start:"
  "    mov rax, 12"
  "    mov rdi, 0"
  "    syscall"
  "    mov rdi, rax"
  "    mov r8, rax"
  "    add rdi, 0x8000"
  "    mov rax, 12"
  "    syscall"
  "    mov rsi, rax"
  "    mov rcx, 0x8000"
  "    mov dl, 0"
  "bf_memset:"
  "    dec rsi"
  "    mov BYTE [rsi], dl"
  "    dec rcx"
  "    jnz bf_memset"
âŸ©

footer â† UnlinesâŸ¨
  "    mov rax, 60"
  "    mov rdi, 0"
  "    syscall"
âŸ©

FwdJmp â† {
  UnlinesâŸ¨
    "b"âˆ¾(â€¢Fmtğ•¨)âˆ¾":"
    "    mov al, BYTE [rsi]"
    "    test al, al"
    "    jz e"âˆ¾â€¢Fmtğ•¨
  âŸ©
}Â¨

BackJmp â† {
  UnlinesâŸ¨
    "    jmp b"âˆ¾â€¢Fmtğ•¨,
    "e"âˆ¾(â€¢Fmtğ•¨)âˆ¾":",
  âŸ©
}Â¨

Plus â† {
  UnlinesâŸ¨
    "    mov al, "âˆ¾â€¢Fmt 256|ğ•©
    "    add al, BYTE [rsi]"
    "    mov BYTE [rsi], al"
  âŸ©
}

Minus â† Plusâˆ˜-

Left â†  {"    sub rsi, "âˆ¾â€¢Fmtğ•©}

Right â† {"    add rsi, "âˆ¾â€¢Fmtğ•©}

read â† UnlinesâŸ¨
  "    mov rax, 0"
  "    mov rdi, 0"
  "    mov rdx, 1"
  "    syscall"
âŸ©

write â† UnlinesâŸ¨
  "    mov rax, 1"
  "    mov rdi, 1"
  "    mov rdx, 1"
  "    syscall"
âŸ©

# Discard any characters that are not supported by the language.
input â† âˆŠâŸœ"+-,.<>[]"âŠ¸/â€¢file.BytesâŠ‘â€¢args

# Run-length encoding of the instructions: "+-<>" are joined.
split â† (â‰ âŸœÂ» âˆ¨ Â¬âˆ˜âˆŠâŸœ"+-<>")input
type  â† split/input
count â† 1â†“/â¼+`split

# To generate matching IDs for the forward and backward jumps, we first compute
# a depth vector. For any given depth, the closing brace of a pair always
# occurs before any other closing brace at the same depth. This means that the
# 'âŠ’' primitive gives the index in 'begins' of the brace each element in 'ends'
# closes.
# TODO: validate that the brackets are balanced.
beginsâ€¿ends â† "[]"=Â¨<type
depth â† +`begins-Â»ends
forwardâ€¿back â† (â†•âˆ˜â‰ â‹ˆâŠ¢) begins âŠ’â—‹(/âŸœdepth) ends

# Dispatch on the type of the instruction, calling the appropriate codegen
# function with the run-length as ğ•©. The jumps will result in "" and are
# patched later.
output â† ("+-<>,."âŠtype){ğ•¨â—¶âŸ¨Plus, Minus, Left, Right, read, write, ""âŸ©ğ•©}Â¨count

# patch the jump locations by generating appropriate labels from 'forward' and
# 'back'.
output â†© forwardâŠ¸FwdJmpâŒ¾(beginsâŠ¸/)output
output â†© backâŠ¸BackJmpâŒ¾(endsâŠ¸/)output

â€¢Out Unlines header<âŠ¸âˆ¾outputâˆ¾âŸœ<footer
