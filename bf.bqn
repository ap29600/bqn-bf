Unlines â† âˆ¾âŸœ(@+10)âŠ¸âˆ¾Â´

# allocate 32KiB with the 'brk' syscall.
# TODO: make the amount of memory configurable.
header â† "section .text
global _start
_start:
    mov rax, 12
    mov rdi, 0
    syscall
    mov rdi, rax
    mov r8, rax
    add rdi, 0x8000
    mov rax, 12
    syscall
    mov rsi, rax
    mov rcx, 0x1000
    xor rdx, rdx
bf_memset:
    sub rsi, 8
    mov qword[rsi], rdx
    dec rcx
    jnz bf_memset"

footer â† "    mov rax, 60
    mov rdi, 0
    syscall
bf_infinite_loop:
    jmp bf_infinite_loop"

FwdJmp â† {
"b"âˆ¾ğ•©âˆ¾":
    mov al, BYTE [rsi]
    test al, al
    jz f"âˆ¾ğ•©
}âˆ˜â€¢Fmt

BckJmp â† {
"    jmp b"âˆ¾ğ•©âˆ¾"
f"âˆ¾ğ•©âˆ¾":"
}âˆ˜â€¢Fmt

Plus â† {
"    mov al, "âˆ¾ğ•©âˆ¾"
    add al, BYTE [rsi]
    mov BYTE [rsi], al"
}âˆ˜(â€¢Fmt 256âŠ¸|)

Minus â† Plusâˆ˜-

Left â†  "    sub rsi, "âˆ¾â€¢Fmt

Right â† "    add rsi, "âˆ¾â€¢Fmt

read â† "    mov BYTE [rsi], dl
    mov rax, 0
    mov rdi, 0
    mov rdx, 1
    syscall"

write â† "    mov rax, 1
    mov rdi, 1
    mov rdx, 1
    syscall"

# we interpret the loop to find the increments and decrements on variables,
# then we find the modular pseudo-inverse of the loop counter's increment.
Unroll â† {tâ€¿câ€¿i:
  off â† +`cÃ—-Ë"><"=âŒœt
  sum â† 256|cÃ—-Ë"+-"=âŒœt

  decrement â† -+Â´sumÃ—0=off
  # the largest power of two dividing the increment.
  # we introduce an assertion that the initial value of the cell is
  # divisible by this value, otherwise we can just halt the program.
  pow2 â† âŠ‘(âŒ½2â‹†â†•9)(âŠ£/Ëœ0=|)decrement
  modulus â† 256Ã·pow2
  inverse â† âŠ‘/pow2=â—‹(256âŠ¸|)decrementÃ—â†•modulus

  # discard all operations on the initial cell, as that will always be zeroed
  # after the guard.
  offâ€¿sum â†© offâ€¿sum/ËœÂ¨<(sumâ‰ 0)âˆ§offâ‰ 0

  # TODO: refactor logic
  result â† ((0<â‰ off)âˆ¨1â‰ pow2)/âŸ¨
    "    mov cl, BYTE[rsi]"
    "    test cl, cl"
    "    jz u"âˆ¾â€¢Fmt i
  âŸ©
  result âˆ¾â†© (1â‰ pow2)/âŸ¨
    "    mov al, cl"
    "    and al, "âˆ¾(â€¢Fmt pow2-1)
    "    jnz bf_infinite_loop"
    "    shr cl, "âˆ¾(â€¢Fmt 2â‹†â¼pow2)
  âŸ©
  result âˆ¾â†© âŸ¨
    "    mov BYTE[rsi], 0"
  âŸ©

  result âˆ¾â†© {
    ind â† "BYTE[rsi"âˆ¾("-+"âŠËœğ•¨â‰¥0)âˆ¾(â€¢Fmt|ğ•¨)âˆ¾']'
    result â† âŸ¨"    mov al, cl"âŸ©
    resultâˆ¾â†© (âˆ¨Â´1â‰ ğ•©â€¿inverse)/âŸ¨
      "    mov dl, "âˆ¾â€¢Fmt 256|ğ•©Ã—inverse
      "    mul dl"
    âŸ©
    resultâˆ¾â†© âŸ¨
      "    add al, "âˆ¾ind
      "    mov "âˆ¾indâˆ¾", al"
    âŸ©
    Unlines result
  }Â¨Â´ offâ€¿sum

  result âˆ¾â†©âŸ¨ "u"âˆ¾(â€¢Fmt i)âˆ¾":" âŸ©

  Unlines result
}

# Discard any characters that are not supported by the language.
input â† âˆŠâŸœ"+-,.<>[]"âŠ¸/â€¢file.BytesâŠ‘â€¢args

# Run-length encoding of the instructions: "+-<>" are joined.
split â† (â‰ âŸœÂ» âˆ¨ Â¬âˆ˜âˆŠâŸœ"+-<>")input
type  â† split/input
count â† 1â†“/â¼+`split

# To generate matching IDs for the forward and backward jumps, we first compute
# a depth vector. For any given depth, the closing brace of a pair always
# occurs before any other closing brace at the same depth. This means that the
# 'âŠ’' primitive gives the index in 'begins' of the brace each element in 'ends'
# closes.
# TODO: validate that the brackets are balanced.
wbeginsâ€¿wends â† /Â¨beginsâ€¿ends â† "[]"=Â¨<type
depth â† +`beginsÂ»âŠ¸-ends

forwardâ€¿back â† (âŠ¢â‹ˆâ†•âˆ˜â‰ ) ends âŠ’â—‹(/âŸœdepth) begins
wbegins â†© backâŠwbegins
wends   â†© forwardâŠwends
metadata â† forwardâŒ¾(beginsâŠ¸/) backâŒ¾(endsâŠ¸/) count

###### Loop unrolling

# Find the deepest nested braces for loop unrolling. These are the ones where
# the closest opening brace on the left is the same as the matching brace.
inner_loop_indices â† /forward=wendsâˆ§âŠ¸â‹wbegins
inner_loop_bodies â† wbegins {(1+ğ•¨)â†“Â¨ğ•©â†‘Â¨typeâ€¿count}Â¨â—‹(inner_loop_indicesâŠ¸âŠ) wends

unrollable â† {tâ€¿c: (Â¬âˆ¨Â´â¥Š",."=âŒœt) âˆ§ 0=+Â´cÃ—-Ë"><"=âŒœt }Â¨inner_loop_bodies
unrolled â† UnrollÂ¨ unrollable/inner_loop_bodiesâˆ¾Â¨inner_loop_indices
unroll_beginsâ€¿unroll_ends â† (unrollable/inner_loop_indices)âŠ¸âŠÂ¨wbeginsâ€¿wends
unroll_mask â† Â¬(â‰ type)â†‘/â¼âˆ¾unroll_ends(1+âŠ¢+â†•âˆ˜-)Â¨unroll_begins

metadata â†© unrolledâŒ¾(unroll_beginsâŠ¸âŠ) metadata
type     â†© 'u'Â¨âŒ¾(unroll_beginsâŠ¸âŠ) type
metadataâ€¿type â†© metadataâ€¿type/ËœÂ¨< unroll_mask

###### Code generation

# Dispatch on the type of the instruction, calling the appropriate codegen
# function with additional arguments (run length or jump label) as ğ•©.
output â† ("+-<>,.[]u"âŠtype){ğ•¨â—¶âŸ¨
  Plus, Minus,
  Left, Right,
  read, write,
  FwdJmp, BckJmp,
  âŠ¢, !
âŸ©ğ•©}Â¨metadata

â€¢Out Unlines header<âŠ¸âˆ¾outputâˆ¾âŸœ<footer
