âŸ¨CompileâŸ©â‡

Merge â† {(â‹â‹ğ•¨)âŠâˆ¾((â‰ ğ•©)â†‘/â¼ğ•¨)â¥ŠÂ¨ğ•©}

Header â† {
  ğ•Šsize:
  nâ€¿s â† â€¢FmtÂ¨8â€¿1Ã—âŒˆsizeÃ·8
"section .text
global _start
_start:
    mov rax, 12
    mov rdi, 0
    syscall
    mov rdi, rax
    mov r8, rax
    add rdi, "âˆ¾nâˆ¾"
    mov rax, 12
    syscall
    mov rsi, rax
    mov rcx, "âˆ¾sâˆ¾"
    xor rdx, rdx
bf_memset:
    sub rsi, 8
    mov qword[rsi], rdx
    dec rcx
    jnz bf_memset
"
}
footer â† "
    mov rax, 60
    mov rdi, 0
    syscall
bf_infinite_loop:
    jmp bf_infinite_loop"
FwdJmp â† {
  f â† â€¢FmtÂ¨ğ•©
"loopbegin"âŠ¸âˆ¾Â¨fâˆ¾Â¨":
    mov al, BYTE [rsi]
    test al, al
    jz loopend"âŠ¸âˆ¾Â¨fâˆ¾Â¨(@+10)
}
BckJmp â† {
  fâ†â€¢FmtÂ¨ğ•©
"    jmp loopbegin"âŠ¸âˆ¾Â¨fâˆ¾Â¨"
loopend"âŠ¸âˆ¾Â¨fâˆ¾Â¨<":
"
}
Plus â† {
"    add BYTE[rsi], "âŠ¸âˆ¾Â¨(â€¢FmtÂ¨ 256|ğ•©)âˆ¾Â¨<"
"
}
Left â†  ("    sub rsi, "âˆ¾â€¢Fmtâˆ¾(@+10)Ë™)Â¨
Right â† ("    add rsi, "âˆ¾â€¢Fmtâˆ¾(@+10)Ë™)Â¨
read â† "    mov BYTE [rsi], dl
    mov rax, 0
    mov rdi, 0
    mov rdx, 1
    syscall
"
write â† "    mov rax, 1
    mov rdi, 1
    mov rdx, 1
    syscall
"
Func â† {
  fâ†â€¢FmtÂ¨ğ•©
"    call funcbegin"âŠ¸âˆ¾Â¨fâˆ¾Â¨"
    jmp  funcend"âŠ¸âˆ¾Â¨fâˆ¾Â¨"
funcbegin"âŠ¸âˆ¾Â¨fâˆ¾Â¨":
    mov al, BYTE[rsi]
    test al,al
    jz funcret"âŠ¸âˆ¾Â¨fâˆ¾Â¨<"
"
}
Return â† {
  fâ†â€¢FmtÂ¨ğ•©
"    mov al, BYTE[rsi]
    test al, al
    jnz funcbegin"âŠ¸âˆ¾Â¨fâˆ¾Â¨"
funcret"âŠ¸âˆ¾Â¨fâˆ¾Â¨":
    ret
funcend"âŠ¸âˆ¾Â¨fâˆ¾Â¨<":
"
}
Call â† {
f â† â€¢FmtÂ¨ğ•©
"    call funcbegin"âŠ¸âˆ¾Â¨fâˆ¾Â¨<"
"
}

# we interpret the loop to find the increments and decrements on variables,
# then we find the modular pseudo-inverse of the loop counter's increment.
# TODO: make this operate on `type` to disentangle from
#       begins and ends.
Unroll â† {typeâ€¿infoâ€¿label:
  off â† +`infoÃ—-Ë"><"=âŒœtype
  sum â† 256|infoÃ—-Ë"+-"=âŒœtype
  # normalize increments. 0 will come first.
  uoffâ†â·0âˆ¾(sumâ‰ 0)/off
  usumâ†(uoff=âŒœoff) +Â´âˆ˜/â‰1 sum
  decrement â† -âŠusum
  uoff 1âŠ¸â†“â†©
  usum 1âŠ¸â†“â†©
  # the largest power of two dividing the increment.
  # we introduce an assertion that the initial value of the cell is
  # divisible by this value, otherwise we can just halt the program.

  pow2 â† âŠ‘(âŒ½2â‹†â†•9)(âŠ£/Ëœ0=|)decrement
  modulus â† 256Ã·pow2
  inverse â† âŠ‘/pow2=â—‹(256âŠ¸|)decrementÃ—â†•modulus

  result â† (1=pow2)âŠ‘âŸ¨
"    mov cl, BYTE[rsi]
    test cl, "âˆ¾(â€¢Fmt pow2-1)âˆ¾"
    jnz bf_infinite_loop
    shr cl, "âˆ¾(â€¢Fmt 2â‹†â¼pow2)âˆ¾"
    mov BYTE[rsi], 0
"
    (0=â‰ off)âŠ‘âŸ¨
"    mov cl, BYTE[rsi]
    test cl, cl
    jz unroll"âˆ¾(â€¢Fmt label)âˆ¾"
    mov BYTE[rsi], 0
",
"    mov BYTE[rsi], 0
"
    âŸ©
  âŸ©

  result âˆ¾â†© âˆ¾{
    mem â† "BYTE[rsi"âˆ¾("-+"âŠËœğ•¨â‰¥0)âˆ¾(â€¢Fmt|ğ•¨)âˆ¾']'
    (1=256|inverseÃ—ğ•©)âŠ‘âŸ¨
"    mov al, cl
    mov dl, "âˆ¾(â€¢Fmt 256|ğ•©Ã—inverse)âˆ¾"
    mul dl
    add "âˆ¾memâˆ¾", al
",
"    mov al, cl
    add "âˆ¾memâˆ¾", al
"
    âŸ©
  }Â¨Â´ uoffâ€¿usum

  result âˆ¾â†© "unroll"âˆ¾(â€¢Fmt label)âˆ¾":
"
  result
}

Compile â‡ {
  ###### Parsing
  # Run-length encoding of the instructions: "+-<>" are joined.
  input â† âˆŠâŸœ"+-<>,.[]"âŠ¸/ğ•©
  split â† (â‰ âŸœÂ» âˆ¨ Â¬âˆ˜âˆŠâŸœ"+-<>")input
  type  â† split/input
  info â† 1â†“/â¼+`split

  # To generate matching IDs for the forward and backward jumps, we first compute
  # a depth vector. For any given depth, the closing brace of a pair always
  # occurs before any other closing brace at the same depth. This means that the
  # 'âŠ’' primitive gives the index in 'ends' of the brace that closes the scope which
  # each element in 'begin' opens.
  beginsâ€¿ends â† /Â¨begin_maskâ€¿end_mask â† "[]"=Â¨<type
  depth â† +`begin_maskÂ»âŠ¸-end_mask
  "Unmatched braces in source file"! (begins =â—‹â‰  ends) âˆ§ 0=âŒŠÂ´depth
  matching â† begins â‹âŠ¸âŠâ—‹(â‹âŠâŸœdepth) ends

  #### Lift loops to function
  {
    loop_id â† âŠËœbegins {ğ•¨â†“Â¨ğ•©â†‘Â¨typeâ€¿info}Â¨ 1+matchingâŠends
    candidates â† (Â¬matching=endsâ‹begins)âˆ§(2=âŠ’loop_id)âˆ§0<begins-ËœmatchingâŠends
    first â† (â‰ begins)â†‘/â¼candidates/loop_id
    call â† first<loop_idâŠfirst>beginsâŠ+`-Â´(â‰ type)â†‘Â¨/â¼Â¨(loop_idâŠfirst)âŠ¸/Â¨1+beginsâ‹ˆmatchingâŠends
    move_mask â† 0<+`-Â´(â‰ type)â†‘Â¨/â¼Â¨callâŠ¸/Â¨1+beginsâ‹ˆmatchingâŠends
    _r â† {ğ•©âŒ¾(ğ•—âŠ¸âŠ)ğ•¨}
    typeâ€¿info (first/begins)_rÂ¨â†© âŸ¨'f'Â¨, first/loop_idâŸ©
    typeâ€¿info (first/matchingâŠends)_rÂ¨â†© âŸ¨'r'Â¨, first/loop_idâŸ©
    typeâ€¿info (call/begins)_rÂ¨â†© âŸ¨'c'Â¨, call/loop_idâŸ©
    typeâ€¿info (/move_mask)_rÂ¨â†© âŸ¨' 'Â¨,0Â¨âŸ©

    kill â† firstâˆ¨callâˆ¨beginsâŠÂ«move_mask
    begins (Â¬kill)âŠ¸/â†©
    ends ((â‹matching)âŠÂ¬kill)âŠ¸/â†©
    matching â†© matching âŠ Â¯1+`(â‹matching)âŠÂ¬kill
    matching (Â¬kill)âŠ¸/â†©
  }

  ###### Loop unrolling
  # Find the deepest nested braces for loop unrolling. These are the ones where
  # the closest closing brace on the right is the same as the matching brace.
  leaf_indices â† /matching=endsâ‹begins
  leaf_bodies â† begins {(1+ğ•¨)â†“Â¨ğ•©â†‘Â¨typeâ€¿info}Â¨â—‹(leaf_indicesâŠ¸âŠ) matchingâŠends

  unrollable â† {tâ€¿c: (Â¬âˆ¨Â´â¥Š",."=âŒœt) âˆ§ 0=+Â´cÃ—-Ë"><"=âŒœt }Â¨leaf_bodies
  unroll_beginsâ€¿unroll_ends â† (unrollable/leaf_indices)âŠ¸âŠÂ¨beginsâ€¿(matchingâŠends)
  unroll_mask â† Â¬(â‰ type)â†‘/â¼âˆ¾1+unroll_begins+â†•Â¨unroll_ends-unroll_begins

  leftover_loop_starts â† Â¬âˆ˜unrollableâŒ¾(leaf_indicesâŠ¸âŠ)(â‰ begins)â¥Š1
  leftover_loop_ends   â† (â‹matching)âŠleftover_loop_starts

  type â†© 'u'Â¨âŒ¾(unroll_beginsâŠ¸âŠ) type
  infoâ€¿type â†© infoâ€¿type/ËœÂ¨< unroll_mask
  ###### Code generation
  instructions â† âŸ¨
    Plus  ('+'=type)/info
    Plusâˆ˜-('-'=type)/info
    Left  ('<'=type)/info
    Right ('>'=type)/info
    <read
    <write
    FwdJmp leftover_loop_starts/matching
    BckJmp leftover_loop_ends/â†•â‰ begins
    Call  ('c'=type)/info
    Func  ('f'=type)/info
    Return('r'=type)/info
    UnrollÂ¨ unrollable/leaf_bodiesâˆ¾Â¨leaf_indices
    <""
  âŸ©

  output â† âˆ¾("+-<>,.[]cfru "âŠtype) Merge instructions
  (Header ğ•¨)âˆ¾outputâˆ¾footer
}

filenamesâ€¿options â† 2â†‘(('-'=âŠ‘Â¨)âŠ”âŠ¢) â€¢args
keysâ€¿values â† (âŠâŸœ':'Â¨(â†‘Â¨â‹ˆ+âŸœ1âŠ¸â†“Â¨)âŠ¢) 1â†“Â¨options
GetOpt â† {âŠ‘(keysâŠ<ğ•©)âŠ(<ğ•¨)âˆ¾Ëœvalues}
ParseIntâ†0 10âŠ¸Ã—âŠ¸+ËœÂ´âŒ½-'0'Ë™
"Exactly one source file should be provided" ! 1=â‰ filenames
("/dev/stdout" GetOpt "out") â€¢file.Bytes (ParseInt "30000" GetOpt "memory") Compile â€¢file.Bytes âŠ‘ filenames
