âŸ¨CompileâŸ©â‡

Merge â† {(â‹â‹ğ•¨)âŠâˆ¾((â‰ ğ•©)â†‘/â¼ğ•¨)â¥ŠÂ¨ğ•©}

GenHeader â† {
  ğ•Šsize:
  nâ€¿s â† â€¢FmtÂ¨8â€¿1Ã—âŒˆsizeÃ·8
"section .text
global _start
_start:
    mov rax, 12
    mov rdi, 0
    syscall
    mov rdi, rax
    mov r8, rax
    add rdi, "âˆ¾nâˆ¾"
    mov rax, 12
    syscall
    mov rsi, rax
    mov rcx, "âˆ¾sâˆ¾"
    xor rdx, rdx
bf_memset:
    sub rsi, 8
    mov qword[rsi], rdx
    dec rcx
    jnz bf_memset
"
}
footer â† "
    mov rax, 60
    mov rdi, 0
    syscall
bf_infinite_loop:
    jmp bf_infinite_loop"
FwdJmp â† {
  f â† â€¢FmtÂ¨ğ•©
"loopbegin"âŠ¸âˆ¾Â¨fâˆ¾Â¨":
    mov al, BYTE [rsi]
    test al, al
    jz loopend"âŠ¸âˆ¾Â¨fâˆ¾Â¨(@+10)
}
BckJmp â† {
  fâ†â€¢FmtÂ¨ğ•©
"    jmp loopbegin"âŠ¸âˆ¾Â¨fâˆ¾Â¨"
loopend"âŠ¸âˆ¾Â¨fâˆ¾Â¨<":
"
}
Add â† {"    add BYTE [rsi], "âŠ¸âˆ¾Â¨(â€¢FmtÂ¨ 256|ğ•©)âˆ¾Â¨@+10}
Move â† {((ğ•©â‰¥0)âŠâŸ¨"    sub rsi, ","    add rsi, "âŸ©)âˆ¾Â¨(â€¢FmtÂ¨|ğ•©)âˆ¾Â¨@+10}
read â† "    mov BYTE [rsi], dl
    mov rax, 0
    mov rdi, 0
    mov rdx, 1
    syscall
"
write â† "    mov rax, 1
    mov rdi, 1
    mov rdx, 1
    syscall
"
Func â† {
  fâ†â€¢FmtÂ¨ğ•©
"    call funcbegin"âŠ¸âˆ¾Â¨fâˆ¾Â¨"
    jmp  funcend"âŠ¸âˆ¾Â¨fâˆ¾Â¨"
funcbegin"âŠ¸âˆ¾Â¨fâˆ¾Â¨":
    mov al, BYTE[rsi]
    test al,al
    jz funcret"âŠ¸âˆ¾Â¨fâˆ¾Â¨<"
"
}
Return â† {
  fâ†â€¢FmtÂ¨ğ•©
"    mov al, BYTE[rsi]
    test al, al
    jnz funcbegin"âŠ¸âˆ¾Â¨fâˆ¾Â¨"
funcret"âŠ¸âˆ¾Â¨fâˆ¾Â¨":
    ret
funcend"âŠ¸âˆ¾Â¨fâˆ¾Â¨<":
"
}
Call â† {
f â† â€¢FmtÂ¨ğ•©
"    call funcbegin"âŠ¸âˆ¾Â¨fâˆ¾Â¨(@+10)
}

Mul â† {idâ€¿[offset, increment]:
  decrement â† -(offsetâŠ0)âŠincrementâˆ¾0
  offsetâ€¿increment (0â‰ offset)âŠ¸/Â¨â†©
  pow2 â† âŠ‘(âŒ½2â‹†â†•9)(âŠ£/Ëœ0=|)decrement
  modulus â† 256Ã·pow2
  inverse â† âŠ‘/pow2=â—‹(256âŠ¸|)decrementÃ—â†•modulus

  result â† (1=pow2)âŠ‘âŸ¨
"    mov cl, BYTE[rsi]
    test cl, "âˆ¾(â€¢Fmt pow2-1)âˆ¾"
    jnz bf_infinite_loop
    shr cl, "âˆ¾(â€¢Fmt 2â‹†â¼pow2)âˆ¾"
    mov BYTE[rsi], 0
"
    (0=â‰ offset)âŠ‘âŸ¨
"    mov cl, BYTE[rsi]
    test cl, cl
    jz multiply"âˆ¾(â€¢Fmt id)âˆ¾"
    mov BYTE[rsi], 0
",
"    mov BYTE[rsi], 0
"
    âŸ©
  âŸ©

  result âˆ¾â†© âˆ¾{
    mem â† "BYTE[rsi"âˆ¾("-+"âŠËœğ•¨â‰¥0)âˆ¾(â€¢Fmt|ğ•¨)âˆ¾']'
    (1=256|inverseÃ—ğ•©)âŠ‘âŸ¨
"    mov al, cl
    mov dl, "âˆ¾(â€¢Fmt 256|ğ•©Ã—inverse)âˆ¾"
    mul dl
    add "âˆ¾memâˆ¾", al
",
"    mov al, cl
    add "âˆ¾memâˆ¾", al
"
    âŸ©
  }Â¨Â´ offsetâ€¿increment
  resultâˆ¾"multiply"âˆ¾(â€¢Fmt id)âˆ¾":
"
}

Compile â‡ { memoryâ€¿use_mulâ€¿deinline ğ•Š ğ•©:
  # Run-length encoding of the instructions: "+-<>" are joined.
  input â† âˆŠâŸœ"+-<>,.[]"âŠ¸/ğ•©
  split â† (â‰ âŸœÂ» âˆ¨ Â¬âˆ˜âˆŠâŸœ"+-<>")input
  type  â† split/input
  info  â† 1â†“/â¼+`split
	# normalize -1 to +256
  info (256|-)âŒ¾((type='-')âŠ¸/) â†©
  type '+'Â¨âŒ¾((type='-')âŠ¸/) â†©
	# normalize <1 to >Â¯1
  info -âŒ¾((type='<')âŠ¸/) â†©
  type '>'Â¨âŒ¾((type='<')âŠ¸/) â†©

  # match brackets
  {
    beginsâ€¿ends â† /Â¨begin_maskâ€¿end_mask â† "[]"=Â¨<type
    depth â† +`begin_maskÂ»âŠ¸-end_mask
    "Unmatched braces in source file"! (begins =â—‹â‰  ends) âˆ§ 0=âŒŠÂ´depth
    matching â† begins â‹âŠ¸âŠâ—‹(â‹âŠâŸœdepth) ends
    info {ğ•©âŒ¾((beginsâˆ¾matchingâŠends)âŠ¸âŠ)ğ•¨}â†© âˆ¾Ëœâ†•â‰ begins
  }

  {ğ•©â‹„# Lift loops to functions
     # a call is denoted by âŸ¨'c', function_idâŸ©
    beginsâ€¿ends â† /Â¨"[]"=Â¨<type
    endsâ†©(â‹ begins â‹â—‹(âŠâŸœinfo) ends)âŠends

		ti â† typeâ‹ˆinfoÃ—Â¬typeâˆŠ"[]"
    loop_id â† âŠËœbegins {(1+ğ•¨)â†“Â¨ğ•©â†‘Â¨ti}Â¨ ends
    candidates â† (â†•âˆ˜â‰ âŠ¸â‰ Â¯1+beginsâ‹ends)âˆ§(1=âŠ’loop_id)âˆ§5<ends-begins
    first â† (â‰ begins)â†‘/â¼candidates/loop_id
    call â† first<loop_idâŠfirst>beginsâŠ+`-Â´(â‰ type)â†‘Â¨/â¼Â¨(loop_idâŠfirst)âŠ¸/Â¨1+beginsâ‹ˆends
    del_mask â† 0<+`â¥Š-Â´(â‰ type)â†‘Â¨/â¼Â¨callâŠ¸/Â¨1+beginsâ‹ˆends
    pos â† (â¥Šfirst/beginsâˆ¾Ë˜ends)âˆ¾call/begins
    new_type â† ("fr"â¥ŠËœ2Ã—+Â´first)âˆ¾'c'â¥ŠËœ+Â´call
    new_info â† (2/first/loop_id)âˆ¾call/loop_id
    typeâ€¿info {ğ•©âŒ¾(posâŠ¸âŠ)ğ•¨}Â¨â†© new_typeâ€¿new_info
    typeâ€¿info (Â¬del_mask)âŠ¸/Â¨â†©
  }âŸdeinline @

  {ğ•©â‹„# Unroll loops to multiplication
     # an unrolled loop is denoted by âŸ¨'u', [positions, increments] âŸ©
    beginsâ€¿ends â† /Â¨"[]"=Â¨<type
    endsâ†©(â‹ begins â‹â—‹(âŠâŸœinfo) ends)âŠends

    indices â† /â†•âˆ˜â‰ âŠ¸=Â¯1+beginsâ‹ends
		ti â† typeâ€¿info
    loop_typesâ€¿loop_infos â† (âŠ£Â´Â¨â‹ˆâŠ¢Â´Â¨)begins {(1+ğ•¨)â†“Â¨ğ•©â†‘Â¨ti}Â¨â—‹(indicesâŠ¸âŠ) ends
    pure   â† âˆ§Â´âˆ˜âˆŠâŸœ"+>"Â¨loop_types              # loops that don't perform IO or call functions
    static â† 0=+Â´Â¨loop_infos/Â¨Ëœ'>'=Â¨loop_types # loops that start and end on the same cell
    indicesâ€¿loop_typesâ€¿loop_infos (pureâˆ§static)âŠ¸/Â¨â†©

    del_mask â† 0<+`â¥Š-Â´(â‰ type)â†‘Â¨/â¼Â¨indicesâŠ¸âŠÂ¨1+beginsâ‹ˆends
    pos â† indicesâŠbegins
    new_type â† '*'â¥ŠËœâ‰ indices
    new_info â† indicesâ‹ˆÂ¨loop_types {(w/j)â‰Ëœ(âŒŠÂ´c)+/wâ†0â‰ jâ†256|+Â´Â¨(iâŠğ•©)âŠ”Ëœc-âŒŠÂ´câ†(iâ†/'+'=ğ•¨)âŠ+`ğ•©Ã—'>'=ğ•¨}Â¨ loop_infos
    typeâ€¿info {ğ•©âŒ¾(posâŠ¸âŠ)ğ•¨}Â¨â†© new_typeâ€¿new_info
    typeâ€¿info (Â¬del_mask)âŠ¸/Â¨â†©
  }âŸuse_mul @

  # Code generation
  d â† âŸ¨Add,Move,<read,<write,FwdJmp,BckJmp,Call,Func,Return,MulÂ¨,<""âŸ©
  t â† "+>,.[]cfr*"
  instructions â† d {ğ• ğ•©}Â¨(1+â‰ t)â†‘infoâŠ”ËœtâŠtype
  output â† âˆ¾(tâŠtype) Merge instructions
  (GenHeader memory)âˆ¾outputâˆ¾footer
}

filenamesâ€¿options â† 2â†‘(('-'=âŠ‘Â¨)âŠ”âŠ¢) â€¢args
keysâ€¿values â† (âŠâŸœ':'Â¨(â†‘Â¨â‹ˆ+âŸœ1âŠ¸â†“Â¨)âŠ¢) 1â†“Â¨options
GetStr   â† {âŠ‘(keysâŠ<ğ•©)âŠvaluesâˆ¾<ğ•¨}
ParseInt â† 0 10âŠ¸Ã—âŠ¸+ËœÂ´âŒ½-'0'Ë™
GetInt   â† {
  oâ†(â€¢Fmtğ•¨) GetStr ğ•©
  ("Expected number argument for option `"âˆ¾ğ•©âˆ¾"`")!(Ã—â‰ o)âˆ§âˆ§Â´1="0:"â‹o
  ParseInt o
}
GetBool  â† {
  iâ†âŠ‘âŸ¨"no","off","0","yes","on","1"âŸ©âŠ<oâ†(â€¢Fmtğ•¨)GetStr ğ•©
  ("Expected boolean argument for option `"âˆ¾ğ•©âˆ¾"`")!6â‰¥i
  i>3
}

"Exactly one source file should be provided" ! 1=â‰ filenames
out_file â† "/dev/stdout" GetStr "out"
memory   â† 30000 GetInt  "memory"
use_mul  â† 1     GetBool "use-mul"
deinline â† 1     GetBool "deinline"
out_file â€¢file.Bytes memoryâ€¿use_mulâ€¿deinline Compile â€¢file.Bytes âŠ‘ filenames
